{"ast":null,"code":"let aesjs = require('aes-js');\n\nlet pbkdf2 = require('pbkdf2'); // Hex to Bytes\n\n\nexport let decryptKeyCBC = (password, studyKey, iv, salt) => {\n  let studyKeyBytes = aesjs.utils.hex.toBytes(studyKey); // correct\n  // Salt to a Buffer\n\n  let bitSalt = aesjs.utils.hex.toBytes(salt); // correct\n\n  let initVector = aesjs.utils.hex.toBytes(iv); // correct\n\n  let buffSalt = Buffer.from(bitSalt);\n  let buffInitVector = Buffer.from(initVector); // // The cipher-block chaining mode of operation maintains internal\n  // // state, so to decrypt a new instance must be instantiated.\n\n  let derivedKey_k2 = pbkdf2.pbkdf2Sync(password, buffSalt, 2300, 16, 'sha512'); //\n\n  let aesCbc = new aesjs.ModeOfOperation.cbc(derivedKey_k2, buffInitVector);\n  let decryptedBytes = aesCbc.decrypt(studyKeyBytes); //\n  // Convert our bytes back into text\n\n  let decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\n  return decryptedText;\n};","map":{"version":3,"sources":["/home/mspl/Desktop/peerformance_frontend/src/Utils/DecryptKeyCBC.js"],"names":["aesjs","require","pbkdf2","decryptKeyCBC","password","studyKey","iv","salt","studyKeyBytes","utils","hex","toBytes","bitSalt","initVector","buffSalt","Buffer","from","buffInitVector","derivedKey_k2","pbkdf2Sync","aesCbc","ModeOfOperation","cbc","decryptedBytes","decrypt","decryptedText","utf8","fromBytes"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB,C,CACA;;;AACA,OAAO,IAAIE,aAAa,GAAG,CAACC,QAAD,EAAWC,QAAX,EAAqBC,EAArB,EAAyBC,IAAzB,KAAkC;AACzD,MAAIC,aAAa,GAAGR,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBN,QAAxB,CAApB,CADyD,CACF;AAE3D;;AACI,MAAIO,OAAO,GAAGZ,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBJ,IAAxB,CAAd,CAJyD,CAIZ;;AAC7C,MAAIM,UAAU,GAAGb,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBL,EAAxB,CAAjB,CALyD,CAKX;;AAC9C,MAAIQ,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAYJ,OAAZ,CAAf;AACA,MAAIK,cAAc,GAAGF,MAAM,CAACC,IAAP,CAAYH,UAAZ,CAArB,CAPyD,CAU7D;AACA;;AACI,MAAIK,aAAa,GAAGhB,MAAM,CAACiB,UAAP,CAAkBf,QAAlB,EAA4BU,QAA5B,EAAsC,IAAtC,EAA4C,EAA5C,EAAgD,QAAhD,CAApB,CAZyD,CAa7D;;AACI,MAAIM,MAAM,GAAG,IAAIpB,KAAK,CAACqB,eAAN,CAAsBC,GAA1B,CAA8BJ,aAA9B,EAA6CD,cAA7C,CAAb;AACA,MAAIM,cAAc,GAAGH,MAAM,CAACI,OAAP,CAAehB,aAAf,CAArB,CAfyD,CAgB7D;AACA;;AACI,MAAIiB,aAAa,GAAGzB,KAAK,CAACS,KAAN,CAAYiB,IAAZ,CAAiBC,SAAjB,CAA2BJ,cAA3B,CAApB;AACA,SAAOE,aAAP;AACH,CApBM","sourcesContent":["let aesjs = require('aes-js');\nlet pbkdf2 = require('pbkdf2');\n// Hex to Bytes\nexport let decryptKeyCBC = (password, studyKey, iv, salt) => {\n    let studyKeyBytes = aesjs.utils.hex.toBytes(studyKey); // correct\n\n// Salt to a Buffer\n    let bitSalt = aesjs.utils.hex.toBytes(salt); // correct\n    let initVector = aesjs.utils.hex.toBytes(iv); // correct\n    let buffSalt = Buffer.from(bitSalt);\n    let buffInitVector = Buffer.from(initVector);\n\n\n// // The cipher-block chaining mode of operation maintains internal\n// // state, so to decrypt a new instance must be instantiated.\n    let derivedKey_k2 = pbkdf2.pbkdf2Sync(password, buffSalt, 2300, 16, 'sha512');\n//\n    let aesCbc = new aesjs.ModeOfOperation.cbc(derivedKey_k2, buffInitVector);\n    let decryptedBytes = aesCbc.decrypt(studyKeyBytes);\n//\n// Convert our bytes back into text\n    let decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\n    return decryptedText;\n}"]},"metadata":{},"sourceType":"module"}