{"ast":null,"code":"var aesjs=require('aes-js');var pbkdf2=require('pbkdf2');// Hex to Bytes\nexport var decryptKeyCBC=function decryptKeyCBC(password,studyKey,iv,salt){var studyKeyBytes=aesjs.utils.hex.toBytes(studyKey);// correct\n// Salt to a Buffer\nvar bitSalt=aesjs.utils.hex.toBytes(salt);// correct\nvar initVector=aesjs.utils.hex.toBytes(iv);// correct\nvar buffSalt=Buffer.from(bitSalt);var buffInitVector=Buffer.from(initVector);// // The cipher-block chaining mode of operation maintains internal\n// // state, so to decrypt a new instance must be instantiated.\nvar derivedKey_k2=pbkdf2.pbkdf2Sync(password,buffSalt,2300,16,'sha512');//\nvar aesCbc=new aesjs.ModeOfOperation.cbc(derivedKey_k2,buffInitVector);var decryptedBytes=aesCbc.decrypt(studyKeyBytes);//\n// Convert our bytes back into text\nvar decryptedText=aesjs.utils.utf8.fromBytes(decryptedBytes);return decryptedText;};","map":{"version":3,"sources":["/home/mspl/Desktop/peerformance_frontend/src/Utils/DecryptKeyCBC.js"],"names":["aesjs","require","pbkdf2","decryptKeyCBC","password","studyKey","iv","salt","studyKeyBytes","utils","hex","toBytes","bitSalt","initVector","buffSalt","Buffer","from","buffInitVector","derivedKey_k2","pbkdf2Sync","aesCbc","ModeOfOperation","cbc","decryptedBytes","decrypt","decryptedText","utf8","fromBytes"],"mappings":"AAAA,GAAIA,CAAAA,KAAK,CAAGC,OAAO,CAAC,QAAD,CAAnB,CACA,GAAIC,CAAAA,MAAM,CAAGD,OAAO,CAAC,QAAD,CAApB,CACA;AACA,MAAO,IAAIE,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAACC,QAAD,CAAWC,QAAX,CAAqBC,EAArB,CAAyBC,IAAzB,CAAkC,CACzD,GAAIC,CAAAA,aAAa,CAAGR,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBN,QAAxB,CAApB,CAAuD;AAE3D;AACI,GAAIO,CAAAA,OAAO,CAAGZ,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBJ,IAAxB,CAAd,CAA6C;AAC7C,GAAIM,CAAAA,UAAU,CAAGb,KAAK,CAACS,KAAN,CAAYC,GAAZ,CAAgBC,OAAhB,CAAwBL,EAAxB,CAAjB,CAA8C;AAC9C,GAAIQ,CAAAA,QAAQ,CAAGC,MAAM,CAACC,IAAP,CAAYJ,OAAZ,CAAf,CACA,GAAIK,CAAAA,cAAc,CAAGF,MAAM,CAACC,IAAP,CAAYH,UAAZ,CAArB,CAGJ;AACA;AACI,GAAIK,CAAAA,aAAa,CAAGhB,MAAM,CAACiB,UAAP,CAAkBf,QAAlB,CAA4BU,QAA5B,CAAsC,IAAtC,CAA4C,EAA5C,CAAgD,QAAhD,CAApB,CACJ;AACI,GAAIM,CAAAA,MAAM,CAAG,GAAIpB,CAAAA,KAAK,CAACqB,eAAN,CAAsBC,GAA1B,CAA8BJ,aAA9B,CAA6CD,cAA7C,CAAb,CACA,GAAIM,CAAAA,cAAc,CAAGH,MAAM,CAACI,OAAP,CAAehB,aAAf,CAArB,CACJ;AACA;AACI,GAAIiB,CAAAA,aAAa,CAAGzB,KAAK,CAACS,KAAN,CAAYiB,IAAZ,CAAiBC,SAAjB,CAA2BJ,cAA3B,CAApB,CACA,MAAOE,CAAAA,aAAP,CACH,CApBM","sourcesContent":["let aesjs = require('aes-js');\nlet pbkdf2 = require('pbkdf2');\n// Hex to Bytes\nexport let decryptKeyCBC = (password, studyKey, iv, salt) => {\n    let studyKeyBytes = aesjs.utils.hex.toBytes(studyKey); // correct\n\n// Salt to a Buffer\n    let bitSalt = aesjs.utils.hex.toBytes(salt); // correct\n    let initVector = aesjs.utils.hex.toBytes(iv); // correct\n    let buffSalt = Buffer.from(bitSalt);\n    let buffInitVector = Buffer.from(initVector);\n\n\n// // The cipher-block chaining mode of operation maintains internal\n// // state, so to decrypt a new instance must be instantiated.\n    let derivedKey_k2 = pbkdf2.pbkdf2Sync(password, buffSalt, 2300, 16, 'sha512');\n//\n    let aesCbc = new aesjs.ModeOfOperation.cbc(derivedKey_k2, buffInitVector);\n    let decryptedBytes = aesCbc.decrypt(studyKeyBytes);\n//\n// Convert our bytes back into text\n    let decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\n    return decryptedText;\n}"]},"metadata":{},"sourceType":"module"}